作業一
繳交截止時間：10/16（禮拜四） 23:59

資料：多個 (id, score) 紀錄，且一個id可能有多個score，例如：(300, 10), (300, 20), (300, 30), (300, 30)


比較以下資料結構：
1.	Solution 1 (dynamic array) + insert to correct position: 初始array大小為1，新的array大小為舊array大小之10倍。
2.	Solution 2 (static array, id as index) + link
3.	Linked_List++: linked list的node位置需要由小排到大（head在RAM的位置最小，tail在RAM的位置最大）

實作以下兩個function：
1.	Insert(id, score)
2.	Search(id): 回傳所有該id的分數；若無，則回傳-1。
Function input產生方式：
3.	Insert: id ~ UNI(1, 2^20), score ~ UNI(0,100)
4.	Search: id~UNI(1, 2^20)

繳交檔案格式：pdf

以下$n = 2^k, k\in {11, 12, 13, ... , 25}$ 

繳交報告內容： 
1.	(45%) 3張折線圖，每張圖包含3條折線，對應到上述3個資料結構。
    - 第1張折線圖x軸為n，y軸為執行n次insert所需的時間。每條折線有15個資料點，每個資料點為10筆實驗做平均。若某個資料點超過10分鐘，則以估計值取代，並解釋估計方法。
    - 第2張折線圖的x軸為n，y軸為執行n次insert後，執行十萬次search所需的時間（不包含新增n筆資料所需的時間）。每條折線有15個資料點，每個資料點為10筆實驗做平均。若某個資料點超過10分鐘，則以估計值取代，並解釋估計方法。
    - 第3張折線圖的x軸為n，y軸為新增n筆資料後，計算score總和所需的時間（不含新增n筆資料所需的時間）每條折線有15個資料點，每個資料點為10筆實驗做平均。若某個資料點超過10分鐘，則以估計值取代，並解釋估計方法。
2.	Insert與Search程式碼與解釋。少一個function的程式碼或解釋扣5分。
3.	(15%) 解釋每一張實驗圖。少一張圖的解釋扣5分。
4.	(10%) 請設計額外的實驗比較這三個資料結構，畫出一張實驗圖，解釋你的實驗動機與結果。 
    - **額外實驗設計：** 測試id介於2^10~2^11間的密集資料會對三個資料結構造成什麼影響。 
5.	(Bonus. 5%) 附上與生成式AI關於此次作業的對話，並描述此次使用AI的優缺點。

---
# AI Code Summary (Updated 2025-10-16)

這份摘要是基於對 `*.cpp`, `*.hpp`, `controller.py` 檔案的分析，並已反映 `main.cpp` 的修正。

## 主要變更

- **`main.cpp` 已修正:** 先前指出的「只會測試 `dynamic_array`」的錯誤已被修復。程式碼被重構成使用一個樣板函式 `run_and_time`，現在可以根據命令列參數正確地測試指定的資料結構。
- **日誌寫入修正:** `result.log` 的寫入方式已從「覆蓋」修正為「附加」，確保多次執行的結果能被完整記錄。

## 各模組摘要

### Solution 1: Dynamic Array (`d_array`)
- **資料結構:** 使用 `std::unique_ptr<std::vector<Node>>`，其中 `Node` 包含 `id` 和 `std::vector<int> scores`。整個陣列 **按ID保持排序**。
- **Insert 邏輯:**
    1.  使用 **二分搜尋** 檢查ID是否存在。
    2.  若存在，將 `score` 加入既有的 `scores` 向量中。
    3.  若不存在，找到應插入的位置，並檢查容量。
    4.  若容量不足 (`count == capacity`)，則擴展陣列為 **10倍** 大小。
    5.  將插入點之後的所有元素向後移動一位，然後插入新節點。
- **Search 邏輯:** 標準的 **二分搜尋**，時間複雜度為 O(log n)。
- **Sum 邏輯:** 遍歷所有節點並累加分數，時間複雜度為 O(n)。

### Solution 2: Static Array (`s_array`)
- **資料結構:** 使用 `std::vector<Node> a`，大小固定為 `2^20`。`id` 直接作為陣列的 **index**。`Node` 包含 `scores` 和 `next_id`，用來將所有**已使用的節點**串成一個按ID排序的單向鏈結串列。
- **Insert 邏輯:**
    1.  核心操作是 `a[id].scores.push_back(score)`，這是一個 O(1) 操作（均攤）。
    2.  之後的程式碼試圖將此 `id` 節點插入到一個全域的、按ID排序的「已使用節點」鏈結串列中。此鏈結串列僅被 `sum()` 函式使用。
- **Search 邏輯:** 直接存取 `a[id]`，檢查其 `scores` 向量是否為空。這是一個純 **O(1)** 操作。
- **Sum 邏輯:** 遍歷那個額外維護的「已使用節點」鏈結串列來加總，避免了遍歷整個 `2^20` 的大陣列，算是一個優化。

### Solution 3: Linked List++ (`llpp`)
- **資料結構:** 一個標準的 `unique_ptr` 鏈結串列。特別的是，它額外使用一個 `std::set<long long> ids` 來快速判斷ID是否存在。
- **Insert 邏輯:**
    1.  **完全按照作業要求實作**：節點在鏈結串列中的順序是根據 **節點在記憶體中的位址** (`node*` 指標的大小) 排序的。
    2.  插入前會先用 `std::set` 檢查ID是否存在 (O(log n))。
    3.  若ID已存在，則需遍歷整個鏈結串列 (O(n)) 找到該ID並添加分數。
    4.  若ID不存在，則創建新節點，然後遍歷鏈結串列 (O(n)) 找到正確的**記憶體位址順序**來插入節點。
- **Search 邏輯:**
    1.  先用 `std::set` 檢查ID是否存在 (O(log n))。
    2.  若存在，仍需遍歷整個鏈結串列 (O(n)) 來找到對應節點。
- **Sum 邏輯:** 遍歷整個鏈結串列並加總，時間複雜度為 O(n)。

### 實驗執行
- **`controller.py`:**
    - 作為總控制器，正確地迭代三種結構類型、`n` 的各種值以及10次重複實驗。
    - 正確地呼叫C++執行檔，並傳入參數。
    - **成功實作了10分鐘超時機制**，會在超時後終止C++程序。
- **`main.cpp`:**
    - 接收 `controller.py` 傳來的參數。
    - 核心測試邏輯被封裝在樣板函式 `run_and_time<T>` 中。
    - `main` 函式根據命令列參數，呼叫 `run_and_time` 的特定版本 (e.g., `run_and_time<dynamic_array>(...)`) 來執行對應的測試。
