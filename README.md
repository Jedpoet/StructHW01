# 資料結構作業一：三種儲存結構的效能分析

**作者：** [童玉丞]

**學號：** [113703052]

---

## 專案簡介

本專案旨在實作並比較三種不同的資料結構，用於儲存與查詢 (ID, Score) 的鍵值對，其中一個 ID 可能對應多個 Score。

主要目標是透過實驗，測量 `Insert`, `Search`, `Sum` 三種核心操作在不同資料規模 (n 從 2^11 到 2^25) 下的效能表現，並從理論複雜度與實際硬體運作（如 CPU 快取）的角度，深度分析其效能差異與背後的權衡 (Trade-offs)。

## 資料結構實作

1.  **Solution 1 (`d_array`): 動態陣列**
    *   **結構:** 使用 `std::vector` 實作，內部元素根據 ID 保持排序。陣列容量不足時，會擴展為 10 倍。
    *   **Insert:** 透過二分搜尋找到插入點後，移動後續元素以插入新節點。單次操作為 O(n)，執行 n 次的總複雜度為 **O(n²)**。
    *   **Search:** 使用高效的二分搜尋，複雜度為 **O(log n)**。

2.  **Solution 2 (`s_array`): 靜態陣列 (ID as Index)**
    *   **結構:** 使用一個大小固定為 2^20 的 `std::vector`，以 ID 直接作為陣列索引。為了優化 `sum` 操作，額外維護了一個串連所有已使用節點的鏈結串列。
    *   **Insert:** 核心寫入操作為 O(1)，但維護「已使用節點」的有序鏈結串列需要 O(n) 的成本，導致總複雜度亦為 **O(n²)**。
    *   **Search:** 利用 ID 直接索引，實現了理論最優的 **O(1)** 複雜度。

3.  **Solution 3 (`llpp`): 特殊鏈結串列**
    *   **結構:** 一個標準的鏈結串列，但其節點特殊地根據在記憶體中的位址由小到大進行排序。
    *   **Insert:** 需遍歷串列以找到正確的記憶體位址插入點，總複雜度為 **O(n²)**。
    *   **Search:** 需從頭遍歷整個串列來尋找指定 ID，複雜度為 **O(n)**。

## 如何編譯與執行

### 環境需求
- C++ 編譯器 (支援 C++17, 如 GCC, Clang, MSVC)
- CMake (3.10 或更高版本)
- Python 3
- Python 函式庫: `matplotlib`, `numpy`

可使用以下指令安裝 Python 函式庫：
```bash
pip install matplotlib numpy
```

### 執行步驟

1.  **編譯 C++ 執行檔:**
    ```bash
    # 產生建置系統 (以 Ninja 為例)
    cmake -G "Ninja" -B build

    # 編譯專案
    cmake --build build
    ```
    編譯成功後，會在 `build` 目錄下產生 `StructHW01.exe`。

2.  **執行實驗:**
    `controller.py` 會自動執行 C++ 程式，並將原始數據記錄到 `.log` 檔案中。
    ```bash
    python controller.py
    ```

3.  **分析數據並繪圖:**
    `analyzer.py` 會讀取 `.log` 檔案，整理數據，並要求使用者估計超時的數據點，最後產生 PNG 格式的效能分析圖。
    ```bash
    python analyzer.py
    ```

## 效能分析總結

-   **`Insert` 操作:**
    - `d_array` 和 `llpp` 因其 O(n) 的單次插入成本（陣列元素移動／鏈結串列遍歷），總體效能呈現穩定的 **O(n²)** 增長（數據加倍，時間約變 4 倍）。
    - `s_array` 理論上亦為 O(n²)，但其實測效能因「隨機記憶體存取」導致嚴重的 **CPU 快取失誤 (Cache Miss)**，增長率不穩定，波動較大。

-   **`Search` 操作:**
    - 此操作最能體現結構間的差異。`s_array` 以巨大的記憶體空間換來了 **O(1)** 的極致效能。`d_array` 透過排序和二分搜尋，達到了 **O(log n)** 的高效能。`llpp` 則因其循序遍歷的本質，效能最差，為 **O(n)**。

-   **`Sum` 操作:**
    - 三者均需遍歷所有已儲存的 n 個元素，故複雜度均為 **O(n)**，效能表現在伯仲之間。

本專案的實驗結果清晰地揭示了不同資料結構在時間效率、空間使用與實作複雜度之間的內在權衡。
